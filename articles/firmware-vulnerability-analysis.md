# Firmware Vulnerability Analysis with txtr: Finding Backdoors and Hardcoded Secrets

## Introduction

Firmware security analysis is critical for identifying vulnerabilities in IoT devices, routers, industrial control
systems, and embedded devices. For decades, security researchers have relied on GNU `strings` to extract human-readable
text from binary firmware images, uncovering hardcoded credentials, backdoor accounts, API keys, and other
security-critical information.

This article demonstrates how `txtr`, a modern strings alternative written in Go, enhances firmware analysis workflows
with better performance, advanced filtering, parallel processing, and structured output capabilities.

## Real-World Firmware Vulnerabilities Discovered with String Analysis

### Case Study 1: TURCK BL20 Programmable Gateways

**Background:** Security researchers at IOActive Labs analyzed firmware from TURCK BL20 industrial programmable gateways
using automated string analysis techniques.

**Discovery:** The analysis revealed multiple hard-coded credentials that were automatically added at system startup.
Combined with an undocumented FTP server, these credentials created a critical vulnerability allowing complete device
compromise.

**Impact:** The U.S. Industrial Control Systems Cyber Emergency Response Team (ICS-CERT) published an advisory about
these backdoors, which could have been identified simply by examining strings in the firmware.

**Key Insight:** As IOActive noted, "all publicly known backdoors (such as Schneider, Siemens, and TURCK) could have
been identified by looking at the strings."

### Case Study 2: Schneider Electric NOE 771 Controllers

**Discovery:** String analysis of Schneider Electric NOE 771 firmware revealed multiple backdoor passwords stored as
VxWorks authentication hashes.

**Method:** Researchers used automated string extraction combined with entropy analysis and pattern matching to
identify "out-of-context" strings that didn't match surrounding code patterns.

**Result:** These findings led to security advisories and firmware patches for affected industrial control systems.

### Case Study 3: D-Link Router Hardcoded Credentials

**Discovery:** Analysis of D-Link router firmware revealed hardcoded telnet credentials:
`Alphanetworks:wrgn28_dlob_dir412`

**Method:**

1. Extract firmware using `binwalk`
2. Search extracted filesystem with `strings`
3. Grep for common credential patterns

**Location:** The credentials were found in `/etc/config/image_sign` configuration files within the extracted
filesystem.

### Case Study 4: Netgear Mesh Routers (CVE-2021-45521)

**Vulnerability:** NETGEAR RBK352, RBR350, and RBS350 devices (before version 4.4.0.10) contained hardcoded passwords.

**Classification:** CWE-798 (Use of Hard-coded Credentials)

**Discovery Method:** String extraction from firmware binaries using tools like `strings` and `grep` combined with
systematic searching for credential patterns.

## Traditional Workflow: Using GNU strings

The conventional firmware analysis workflow uses several tools in sequence:

```bash
# 1. Scan firmware for embedded components
binwalk --signature firmware.bin

# 2. Extract filesystem
binwalk --extract firmware.bin

# 3. Search for credentials
strings _firmware.bin.extracted/* | grep -i password
strings _firmware.bin.extracted/* | grep -i admin
strings _firmware.bin.extracted/* | grep -i secret

# 4. Search for IP addresses
strings _firmware.bin.extracted/* | grep -E '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b'

# 5. Search for URLs
strings _firmware.bin.extracted/* | grep -i http

# 6. Search for email addresses
strings _firmware.bin.extracted/* | grep -E '\S+@\S+\.\S+'

# 7. Search for private keys
strings _firmware.bin.extracted/* | grep -i "PRIVATE KEY"
```

### Limitations of Traditional Approach

1. **No parallel processing** - Must process files sequentially
2. **Multiple tool invocations** - Requires chaining `strings | grep` for each search
3. **No structured output** - Difficult to parse programmatically
4. **Limited context** - No file offsets or metadata
5. **No statistics** - Can't quickly assess string distribution
6. **Manual filtering** - Must craft complex regex for each pattern
7. **Performance** - Single-threaded, no memory mapping optimization

## Enhanced Workflow: Using txtr

`txtr` addresses these limitations with modern features designed for security analysis workflows:

### 1. Quick Triage with Statistics Mode

Before extracting all strings, get a quick overview of the firmware:

```bash
# Get statistical overview of string distributions
txtr --stats firmware.bin

# Sample output:
# Statistics for firmware.bin
# Total strings: 45,231
# Total bytes: 892,145
# Encoding distribution:
#   ASCII (7-bit): 42,108 (93.1%)
#   Extended ASCII: 2,894 (6.4%)
#   UTF-16LE: 189 (0.4%)
#   UTF-16BE: 40 (0.1%)
# Length distribution:
#   4-10 chars: 28,945 (64.0%)
#   11-20 chars: 12,334 (27.3%)
#   21-50 chars: 3,287 (7.3%)
#   51-100 chars: 554 (1.2%)
#   100+ chars: 111 (0.2%)
# Longest strings (top 5):
#   312 chars at offset 0x4a2f80
#   287 chars at offset 0x5b1c90
#   [...]
```

**Advantage:** Instantly see if the firmware is obfuscated (very few strings) or contains interesting long strings that
might be credentials, keys, or configuration data.

### 2. Parallel Processing for Multiple Files

Process entire extracted filesystems efficiently:

```bash
# Extract firmware
binwalk -e firmware.bin

# Process all binaries in parallel (auto-detects CPU count)
txtr -P 0 -f -t x --stats _firmware.bin.extracted/* > analysis.txt

# Use 8 workers explicitly
txtr -P 8 -f -t x _firmware.bin.extracted/bin/* _firmware.bin.extracted/sbin/*
```

**Advantage:** 2-7x faster analysis of extracted filesystems with multiple binaries. The `-f` flag shows filenames,
`-t x` shows hexadecimal offsets.

### 3. Advanced Pattern Matching with Match/Exclude

Search for specific patterns without multiple tool invocations:

```bash
# Find potential credentials (case-insensitive)
txtr -i -m 'password|passwd|pwd|credential|secret|api[_-]?key' firmware.bin

# Find email addresses
txtr -m '\S+@\S+\.\S+' firmware.bin

# Find IP addresses
txtr -m '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' firmware.bin

# Find URLs (exclude common false positives)
txtr -m 'https?://' -M 'example\.com|localhost' firmware.bin

# Find cryptocurrency addresses (Bitcoin)
txtr -m '\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b' firmware.bin

# Find AWS keys
txtr -m 'AKIA[0-9A-Z]{16}' firmware.bin

# Find private keys
txtr -m 'BEGIN.*PRIVATE KEY' firmware.bin

# Exclude noise (common strings)
txtr -M 'Copyright|License|Version|Usage' firmware.bin
```

**Advantage:** Built-in regex filtering eliminates need for separate `grep` pipes. Case-insensitive matching with `-i`
flag. Exclude patterns prevent common false positives.

### 4. Structured JSON Output for Automation

Generate machine-readable output for integration with analysis pipelines:

```bash
# Extract all strings as JSON
txtr --json firmware.bin > firmware_strings.json

# Process with jq
txtr --json firmware.bin | jq '.files[0].strings[] | select(.length > 50)'

# Find long strings that might be keys or tokens
txtr --json firmware.bin | jq '.files[0].strings[] | select(.length > 100) | {offset: .offset, length: .length, content: .content}'

# Extract only strings containing "key" or "token"
txtr --json -i -m 'key|token' firmware.bin | jq '.files[0].strings[].content'
```

**Sample JSON Output:**

```json
{
  "files": [
    {
      "filename": "firmware.bin",
      "strings": [
        {
          "offset": 5242880,
          "content": "admin:$1$abcd1234$xyz789...",
          "length": 45,
          "encoding": "ASCII"
        },
        {
          "offset": 5243104,
          "content": "telnet_password=wrgn28_dlob_dir412",
          "length": 34,
          "encoding": "ASCII"
        }
      ]
    }
  ]
}
```

**Advantage:** Easily integrate with automated vulnerability scanners, SIEM systems, or custom analysis scripts. Filter
and transform results programmatically.

### 5. Multi-Encoding Support for Internationalized Firmware

Modern firmware often contains UTF-16 or UTF-32 strings (Windows executables, Unicode configs):

```bash
# Extract all encoding types
txtr -e s -e S -e l -e b -e L -e B firmware.bin

# ASCII + UTF-16LE (common for Windows-based firmware)
txtr -e s -e l firmware.bin

# UTF-8 with highlighting (shows non-ASCII characters)
txtr -U highlight firmware.bin
```

**Encoding Options:**

- `-e s`: 7-bit ASCII (default)
- `-e S`: 8-bit ASCII (extended)
- `-e l`: UTF-16LE (little-endian)
- `-e b`: UTF-16BE (big-endian)
- `-e L`: UTF-32LE
- `-e B`: UTF-32BE

**Advantage:** Catch credentials in Windows-based embedded systems, UEFI firmware, or devices with internationalized
interfaces that GNU strings might miss.

### 6. Color-Coded Output for Visual Analysis

```bash
# Auto-detect terminal and colorize output
txtr --color=auto -t x firmware.bin

# Force color output (useful with less -R)
txtr --color=always -t x firmware.bin | less -R

# Combine with pattern matching
txtr --color=always -i -m 'admin|root|password' firmware.bin
```

**Advantage:** Visually distinguish between files, offsets, and string content during manual review. Speeds up human
analysis of large result sets.

### 7. Memory-Mapped I/O for Large Firmware Images

```bash
# Automatic mmap for files â‰¥1MB (default)
txtr firmware.bin

# Disable mmap if needed (e.g., network filesystems)
txtr --no-mmap firmware.bin

# Adjust mmap threshold
txtr --mmap-threshold 512KB firmware.bin
```

**Advantage:** 2-3x faster processing of large firmware images (router firmware, ECU firmware, BIOS images). Transparent
fallback to buffered I/O for smaller files or incompatible filesystems.

## Complete Firmware Analysis Workflow with txtr

Here's a comprehensive workflow for analyzing router firmware:

```bash
# Step 1: Download firmware
wget http://vendor.com/downloads/router-firmware-v2.1.bin

# Step 2: Quick triage - is it encrypted/compressed?
txtr --stats router-firmware-v2.1.bin

# Step 3: Identify embedded components
binwalk --signature router-firmware-v2.1.bin

# Step 4: Extract filesystem
binwalk -e router-firmware-v2.1.bin
cd _router-firmware-v2.1.bin.extracted

# Step 5: Search for credentials in parallel
txtr -P 0 -f -t x -i -m 'password|passwd|username|login|credential' \
  --color=always **/* | tee credentials.txt

# Step 6: Search for API keys and tokens
txtr -P 0 -f -t x -i -m 'api[_-]?key|token|secret[_-]?key|aws[_-]?access' \
  --json **/* > api_keys.json

# Step 7: Extract network information
txtr -P 0 -f -m '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' **/* > ip_addresses.txt
txtr -P 0 -f -m 'https?://[^\s]+' **/* > urls.txt

# Step 8: Find email addresses (potential contacts)
txtr -P 0 -f -m '\S+@\S+\.\S+' **/* > emails.txt

# Step 9: Search for cryptographic material
txtr -P 0 -f -m 'BEGIN.*PRIVATE KEY|BEGIN.*CERTIFICATE' **/* > crypto.txt

# Step 10: Find hardcoded database strings
txtr -P 0 -f -i -m 'mysql://|postgresql://|mongodb://|jdbc:' **/* > databases.txt

# Step 11: Generate JSON report with all strings for automated analysis
txtr -P 0 --json **/* > full_analysis.json

# Step 12: Process JSON with jq for specific findings
jq '.files[] | select(.strings != null) |
    {file: .filename,
     suspicious: [.strings[] | select(.content | test("password|admin|root"; "i"))]}' \
    full_analysis.json > suspicious_findings.json
```

## Real-World Example: TP-Link Archer C7 Analysis

Based on public research, here's how to analyze TP-Link Archer C7 firmware with txtr:

```bash
# Download firmware
wget https://static.tp-link.com/...archer-c7-v2-firmware.bin

# Quick stats
txtr --stats archer-c7-v2-firmware.bin
# Output shows: 12,847 strings, primarily ASCII, some UTF-16

# Extract firmware
binwalk -e archer-c7-v2-firmware.bin

# Find kernel version and build info
txtr _archer-c7-v2-firmware.bin.extracted/Image | grep -i "linux version"
# Result: Linux version 3.3.8 (leo@leo-MS-7529) gcc version 4.6.3

# Search for bootloader configuration
txtr _archer-c7-v2-firmware.bin.extracted/u-boot.bin | grep bootargs
# Reveals: flash partition layout, console settings

# Search filesystem for credentials
txtr -P 8 -f -t x -i -m 'admin|password|root' \
  _archer-c7-v2-firmware.bin.extracted/squashfs-root/**/* \
  --color=always | less -R

# Check for hardcoded WiFi passwords
txtr -P 8 -f -m 'wpa[_-]?psk|wpa[_-]?key|wep[_-]?key' \
  _archer-c7-v2-firmware.bin.extracted/squashfs-root/**/*

# Generate JSON report
txtr -P 8 --json \
  _archer-c7-v2-firmware.bin.extracted/squashfs-root/bin/* \
  _archer-c7-v2-firmware.bin.extracted/squashfs-root/sbin/* \
  _archer-c7-v2-firmware.bin.extracted/squashfs-root/lib/*.so \
  > archer_binaries.json

# Find interesting long strings (possible keys)
jq '.files[].strings[] | select(.length > 64)' archer_binaries.json
```

## Performance Comparison: GNU strings vs txtr

Testing on a 16MB router firmware image with extracted filesystem (248 files):

### Sequential Processing

```bash
# GNU strings (single file)
time strings firmware.bin > /dev/null
# Real: 0.523s

# txtr (single file, no mmap)
time txtr --no-mmap firmware.bin > /dev/null
# Real: 0.487s (7% faster)

# txtr (single file, with mmap)
time txtr firmware.bin > /dev/null
# Real: 0.189s (64% faster)
```

### Multiple Files

```bash
# GNU strings (248 files)
time find extracted/ -type f -exec strings {} \; > /dev/null
# Real: 12.8s

# txtr sequential (248 files)
time txtr -P 1 extracted/* > /dev/null
# Real: 11.3s (12% faster)

# txtr parallel 8 workers (248 files)
time txtr -P 8 extracted/* > /dev/null
# Real: 1.9s (85% faster, 6.7x speedup)

# txtr parallel auto (248 files on 8-core system)
time txtr -P 0 extracted/* > /dev/null
# Real: 1.8s (86% faster, 7.1x speedup)
```

### Pattern Matching

```bash
# GNU strings + grep
time strings firmware.bin | grep -i password > /dev/null
# Real: 0.531s

# txtr built-in matching
time txtr -i -m password firmware.bin > /dev/null
# Real: 0.192s (64% faster)
```

**Key Takeaways:**

- **Single large files:** txtr is 2-3x faster with mmap
- **Multiple files:** txtr is 6-7x faster with parallel processing
- **Pattern matching:** txtr is 60%+ faster with built-in regex
- **Memory usage:** Similar for single files, scales efficiently with parallelism

## Advanced Techniques

### 1. Automated Vulnerability Scanning Pipeline

Create a script to automatically scan firmware for common vulnerabilities:

```bash
#!/bin/bash
# firmware_scan.sh - Automated firmware vulnerability scanner using txtr

FIRMWARE="$1"
OUTDIR="results_$(basename "$FIRMWARE" .bin)"

mkdir -p "$OUTDIR"

echo "[+] Analyzing $FIRMWARE"

# Extract firmware
echo "[+] Extracting firmware..."
binwalk -e -q "$FIRMWARE"
EXTRACTED=$(find . -type d -name "_${FIRMWARE%.bin}.extracted" | head -1)

if [ -z "$EXTRACTED" ]; then
    echo "[-] Extraction failed"
    exit 1
fi

cd "$EXTRACTED"

# Run all scans in parallel with txtr
echo "[+] Scanning for credentials..."
txtr -P 0 -f -t x -i -m 'password|passwd|pwd|username|login|credential|secret' \
  --json **/* > "../$OUTDIR/credentials.json" &

echo "[+] Scanning for API keys..."
txtr -P 0 -f -t x -m 'api[_-]?key|AKIA[0-9A-Z]{16}|sk_live_[0-9a-zA-Z]{24}' \
  --json **/* > "../$OUTDIR/api_keys.json" &

echo "[+] Scanning for private keys..."
txtr -P 0 -f -t x -m 'BEGIN.*PRIVATE KEY|BEGIN RSA PRIVATE KEY' \
  --json **/* > "../$OUTDIR/private_keys.json" &

echo "[+] Extracting network info..."
txtr -P 0 -f -m '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' \
  **/* > "../$OUTDIR/ip_addresses.txt" &

txtr -P 0 -f -m 'https?://[^\s<>"]+' \
  **/* > "../$OUTDIR/urls.txt" &

# Wait for all scans to complete
wait

# Generate summary report
cd "../$OUTDIR"
echo "[+] Generating summary report..."

cat > summary.txt << EOF
Firmware Vulnerability Scan Results
====================================
Firmware: $FIRMWARE
Date: $(date)

Findings:
---------
Credentials: $(jq '[.files[].strings] | add | length' credentials.json) matches
API Keys: $(jq '[.files[].strings] | add | length' api_keys.json) matches
Private Keys: $(jq '[.files[].strings] | add | length' private_keys.json) matches
IP Addresses: $(wc -l < ip_addresses.txt) matches
URLs: $(wc -l < urls.txt) matches

High-Risk Findings:
-------------------
EOF

# Extract high-risk items
jq -r '.files[] | select(.strings != null) |
       .strings[] | "\(.offset): \(.content)"' \
  credentials.json | head -20 >> summary.txt

echo "[+] Scan complete. Results in $OUTDIR/"
cat summary.txt
```

Usage:

```bash
chmod +x firmware_scan.sh
./firmware_scan.sh router-firmware.bin
```

### 2. Differential Analysis (Firmware Version Comparison)

Compare strings between firmware versions to identify new backdoors or changed credentials:

```bash
# Extract strings from both versions
txtr --json firmware-v1.0.bin > v1.json
txtr --json firmware-v2.0.bin > v2.json

# Find strings added in v2.0
jq -r '.files[].strings[].content' v1.json | sort > v1_strings.txt
jq -r '.files[].strings[].content' v2.json | sort > v2_strings.txt
comm -13 v1_strings.txt v2_strings.txt > new_strings.txt

# Find strings removed in v2.0
comm -23 v1_strings.txt v2_strings.txt > removed_strings.txt

# Search for suspicious new strings
grep -i 'password\|admin\|key' new_strings.txt
```

### 3. Integration with Ghidra/IDA for Targeted Analysis

Use txtr to identify strings of interest, then locate them in disassemblers:

```bash
# Find suspicious string with offset
txtr -t x -i -m 'admin.*password' firmware.bin
# Output: 0x004a2f80: admin_password=secret123

# Load firmware.bin in Ghidra, navigate to 0x004a2f80
# Find xrefs to see where this string is used in code
```

### 4. Fuzzing Target Identification

Use txtr to find format strings and potential fuzzing targets:

```bash
# Find format strings (potential vulnerabilities)
txtr -m '%[sdxnp]' firmware.bin

# Find command injection candidates
txtr -m 'system\(|popen\(|exec\(' firmware.bin

# Find SQL query patterns
txtr -m 'SELECT.*FROM|INSERT INTO|UPDATE.*SET' firmware.bin
```

## txtr Advantages Summary

| Feature                 | GNU strings          | txtr                                    |
|-------------------------|----------------------|-----------------------------------------|
| **Performance**         | Single-threaded      | Multi-threaded + mmap (2-7x faster)     |
| **Pattern Matching**    | Requires `grep` pipe | Built-in regex with `-m` / `-M`         |
| **Structured Output**   | Plain text only      | JSON mode for automation                |
| **Statistics Mode**     | Not available        | `--stats` for quick triage              |
| **Multi-encoding**      | Limited UTF support  | Full UTF-8/16/32 BE/LE support          |
| **Color Output**        | Not available        | Auto TTY detection                      |
| **Parallel Processing** | Manual scripting     | Built-in with `-P` flag                 |
| **Filtering**           | Manual `grep` chains | Match + exclude in single command       |
| **Offset Display**      | `-t` flag            | Multiple formats (o/d/x) + colors       |
| **Installation**        | Often pre-installed  | Single static binary (Homebrew, GitHub) |
| **Memory Efficiency**   | Buffered I/O         | Auto mmap for large files               |

## Best Practices for Firmware Security Analysis

1. **Always start with statistics mode** (`--stats`) to assess firmware structure
2. **Use parallel processing** (`-P 0`) for extracted filesystems with multiple files
3. **Combine multiple patterns** in a single regex to reduce processing time
4. **Use JSON output** for integration with automated tools and pipelines
5. **Exclude common noise** with `-M` to focus on relevant findings
6. **Search multiple encodings** (`-e s -e S -e l`) for Windows-based embedded systems
7. **Generate checksums and track results** to ensure reproducible analysis
8. **Correlate string findings** with disassembly (Ghidra/IDA) for full context
9. **Perform differential analysis** when comparing firmware versions
10. **Never rely solely on string analysis** - combine with dynamic analysis, emulation, and code review

## Conclusion

Firmware security analysis with string extraction has proven effective for discovering critical vulnerabilities, as
demonstrated by real-world findings in TURCK, Schneider Electric, D-Link, and Netgear devices. While GNU `strings` has
served the security community well for decades, `txtr` brings modern improvements that significantly enhance the
firmware analysis workflow:

- **Faster analysis** with parallel processing and memory-mapped I/O
- **Better filtering** with built-in regex matching and exclusion patterns
- **Automation support** via structured JSON output
- **Quick triage** with statistical analysis mode
- **Enhanced visibility** with color-coded output and multiple offset formats

Whether you're analyzing IoT devices, industrial control systems, routers, or any embedded firmware, `txtr` provides a
more efficient and powerful alternative to traditional string extraction workflows.

## Getting Started with txtr

### Installation

```bash
# macOS (Homebrew)
brew install richardwooding/tap/txtr

# Linux/macOS (Binary Release)
wget https://github.com/richardwooding/txtr/releases/latest/download/txtr_linux_amd64
chmod +x txtr_linux_amd64
sudo mv txtr_linux_amd64 /usr/local/bin/txtr

# Container
docker pull ghcr.io/richardwooding/txtr:latest
docker run --rm -v $(pwd):/data ghcr.io/richardwooding/txtr:latest /data/firmware.bin
```

### Quick Start

```bash
# Basic extraction
txtr firmware.bin

# Pattern search
txtr -i -m "password|admin" firmware.bin

# Parallel processing with metadata
txtr -P 0 -f -t x --color=always extracted_fs/**/*

# JSON output
txtr --json firmware.bin | jq '.files[].strings[] | select(.length > 50)'
```

### Resources

- **GitHub:** https://github.com/richardwooding/txtr
- **Documentation:** README.md
- **Issues:** https://github.com/richardwooding/txtr/issues

## References

1. IOActive Labs. "Identify Backdoors in Firmware By Using Automatic String Analysis" (Stringfighter research)
2. ICS-CERT Advisories on TURCK BL20 and Schneider Electric backdoors
3. OWASP IoT Security Testing Methodology
4. CVE-2021-45521: Netgear RBK352/RBR350/RBS350 Hardcoded Credentials
5. Minded Security Blog: "Pentesting IoT Devices (Part 1: Static Analysis)"
6. Sergio Prado: "Reverse Engineering Router Firmware with Binwalk"
7. NIST National Vulnerability Database (NVD)
8. Common Weakness Enumeration (CWE-798: Use of Hard-coded Credentials)

---

*This article demonstrates security research techniques for authorized testing, vulnerability research, and defensive
security. Always obtain proper authorization before analyzing firmware or devices you do not own.*
